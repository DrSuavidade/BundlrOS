/**
 * Supabase Backend for File Asset Hub
 *
 * Implements the IAssetBackend interface using Supabase Storage and Database.
 */

import { createClient } from "@supabase/supabase-js";
import { Asset, Client, Deliverable } from "../types";
import { ClientsApi, DeliverablesApi } from "@bundlros/supabase";

// Initialize the Supabase client
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const STORAGE_BUCKET = "assets";
const ASSETS_TABLE = "file_assets";

export const supabaseBackend = {
    // --- Data Fetching ---

    getClients: async (): Promise<Client[]> => {
        try {
            const clients = await ClientsApi.getAll();
            return clients.map((c) => ({
                id: c.id,
                name: c.name,
            }));
        } catch (e) {
            console.error("Failed to fetch clients", e);
            return [];
        }
    },

    getDeliverables: async (clientId?: string): Promise<Deliverable[]> => {
        try {
            // Assuming we have an API to get deliverables, possibly filtered
            // For now, fetching generic items or using a placeholder if API missing
            // We will try to rely on a 'DeliverablesApi' if it exists, roughly.
            // If not, we'll query the table directly.
            let query = supabase.from("deliverables").select("*");
            if (clientId) query = query.eq("client_id", clientId);
            const { data, error } = await query;
            if (error) throw error;
            return (
                data?.map((d) => ({
                    id: d.id,
                    name: d.title || d.name || "Untitled",
                    clientId: d.client_id,
                    status: d.status,
                })) || []
            );
        } catch (e) {
            console.error("Failed to fetch deliverables", e);
            return [];
        }
    },

    getAssets: async (filter?: {
        clientId?: string;
        deliverableId?: string;
    }): Promise<Asset[]> => {
        try {
            let query = supabase.from(ASSETS_TABLE).select("*");

            if (filter?.clientId) query = query.eq("client_id", filter.clientId);
            if (filter?.deliverableId)
                query = query.eq("deliverable_id", filter.deliverableId);

            const { data, error } = await query.order("uploaded_at", {
                ascending: false,
            });

            if (error) throw error;

            // Transform DB rows to Asset type
            return (data || []).map((row) => ({
                id: row.id,
                filename: row.filename,
                url: row.public_url || "", // Or generate signed URL if private
                type: row.mime_type.startsWith("image/")
                    ? "image"
                    : row.mime_type.startsWith("video/")
                        ? "video"
                        : "document",
                size: row.size_bytes,
                uploadedAt: row.uploaded_at,
                tags: row.tags || [],
                clientId: row.client_id,
                deliverableId: row.deliverable_id,
                previewUrl: row.preview_url || row.public_url,
            }));
        } catch (e) {
            console.error("Failed to fetch assets from Supabase", e);
            return [];
        }
    },

    // --- Upload Flow ---

    /**
     * 1. Get a Signed Upload URL (Supabase Storage)
     * Note: In standard Supabase JS, we usually verify auth then upload directly.
     * But to match the interface, we'll return parameters needed for upload.
     *
     * Actually, simpler path with Supabase JS:
     * We skip "presigned url" pattern if we can iterate directly.
     * But the interface demands `getPresignedUrl`.
     * We will simulate it or implement it if RLS requires signed URLs.
     * For simplicity here, we'll return the path where it SHOULD go, and let `uploadFileToMinIO` handle the actual SDK upload.
     */
    getPresignedUrl: async (
        filename: string,
        mimeType: string
    ): Promise<{ uploadUrl: string; key: string }> => {
        // We'll generate a unique path
        const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
        const ext = filename.split(".").pop();
        const cleanName = filename.replace(/[^a-z0-9]/gi, "_").toLowerCase();
        const key = `${cleanName}-${uniqueSuffix}.${ext}`;

        // Note: Supabase doesn't do typical S3 presigned PUTs easily client-side without edge functions.
        // We will cheat slightly and return the KEY, and allow uploadFileToMinIO to use the Supabase Client.
        return { uploadUrl: "", key };
    },

    uploadFileToMinIO: async (
        passedKey: string, // Key generated by getPresignedUrl
        file: File,
        onProgress: (progress: number) => void
    ): Promise<string> => {
        // Use the passed key if provided, otherwise generate one
        let key = passedKey;
        if (!key) {
            const uniqueSuffix = Date.now();
            const ext = file.name.split(".").pop();
            const cleanName = file.name
                .split(".")[0]
                .replace(/[^a-z0-9]/gi, "_")
                .toLowerCase();
            key = `${cleanName}-${uniqueSuffix}.${ext}`;
        }

        const { data, error } = await supabase.storage
            .from(STORAGE_BUCKET)
            .upload(key, file, {
                cacheControl: "3600",
                upsert: false,
            });

        if (error) {
            throw error;
        }

        onProgress(100);

        // Get public URL
        const {
            data: { publicUrl },
        } = supabase.storage.from(STORAGE_BUCKET).getPublicUrl(key);

        return publicUrl;
    },

    createAsset: async (
        file: File,
        key: string, // This receives the public URL from uploadFileToMinIO in the current flow
        previewUrl: string, // This is duplicative in this flow
        metadata?: { clientId?: string; deliverableId?: string }
    ): Promise<Asset> => {
        // In this flow, 'key' passed to this function is actually the result of uploadFileToMinIO, which we returned as PUBLIC URL.
        // So 'key' == publicUrl.

        const publicUrl = key; // Renaming for clarity
        const fileType = file.type.startsWith("image/")
            ? "image"
            : file.type.startsWith("video/")
                ? "video"
                : "document";

        const newRow = {
            filename: file.name,
            mime_type: file.type,
            size_bytes: file.size,
            public_url: publicUrl,
            preview_url: publicUrl, // For images, same. For docs, might need thumb.
            client_id: metadata?.clientId || null,
            deliverable_id: metadata?.deliverableId || null,
            tags: [],
            uploaded_at: new Date().toISOString(),
        };

        const { data, error } = await supabase
            .from(ASSETS_TABLE)
            .insert(newRow)
            .select()
            .single();

        if (error) throw error;

        return {
            id: data.id,
            filename: data.filename,
            url: data.public_url,
            type: fileType as any,
            size: data.size_bytes,
            uploadedAt: data.uploaded_at,
            tags: data.tags || [],
            clientId: data.client_id,
            deliverableId: data.deliverable_id,
            previewUrl: data.preview_url,
        };
    },

    // --- Metadata Ops ---

    attachAssetToDeliverable: async (
        assetId: string,
        deliverableId: string
    ): Promise<Asset> => {
        const { data, error } = await supabase
            .from(ASSETS_TABLE)
            .update({ deliverable_id: deliverableId })
            .eq("id", assetId)
            .select()
            .single();

        if (error) throw error;
        return mapRowToAsset(data);
    },

    updateAssetMetadata: async (
        assetId: string,
        tags: string[],
        description: string
    ): Promise<Asset> => {
        const { data, error } = await supabase
            .from(ASSETS_TABLE)
            .update({ tags, description }) // Ensure 'description' column exists in DB
            .eq("id", assetId)
            .select()
            .single();

        if (error) throw error;
        return mapRowToAsset(data);
    },
};

// Helper
const mapRowToAsset = (row: any): Asset => ({
    id: row.id,
    filename: row.filename,
    url: row.public_url || "",
    type: row.mime_type.startsWith("image/")
        ? "image"
        : row.mime_type.startsWith("video/")
            ? "video"
            : "document",
    size: row.size_bytes,
    uploadedAt: row.uploaded_at,
    tags: row.tags || [],
    clientId: row.client_id,
    deliverableId: row.deliverable_id,
    previewUrl: row.preview_url || row.public_url,
});
